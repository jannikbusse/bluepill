#define STM32F4 1


#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/flash.h>
#include "timer.h"
#include "dac.h"
#include <math.h>
#include"osc.h"
#include "music.h"
#include "input.h"

#define SAI1_GCR  	MMIO32(SAI1_BASE + 0x0)
#define SAI1_BCR1  	MMIO32(SAI1_BASE + 0x024)
#define SAI1_BCR2  	MMIO32(SAI1_BASE + 0x028)
#define SAI_BFRCR  	MMIO32(SAI1_BASE + 0x02C) //Reset value: 0x0000 0007
#define SAI_BSLOTR	MMIO32(SAI1_BASE + 0x030) //Reset value: 0
#define SAI_BDR  	MMIO32(SAI1_BASE + 0x040) //data register
#define SAI_STATUS  MMIO32(SAI1_BASE + 0x038) 

volatile bool audioSampleEventInterruptFlag = false; //true if a interrupt occurs
volatile bool inputSampleEventInterruptFlag = false; 

inputState inpState;


uint16_t sample_increment = 0;
uint64_t tick_counter = 0;

volatile uint16_t curVoltSignal = 0; //already filtered
volatile uint32_t dummy_variable_not_used = 0;


void init_clock(void);
void init_clock()
{
	rcc_clock_setup_pll(&rcc_hse_8mhz_3v3[RCC_CLOCK_3V3_180MHZ]);
	// rcc_clock_setup_pll(&rcc_hse_8mhz_3v3[3]);
}

void dummy_usage_function(void);
void dummy_usage_function()
{
	dummy_variable_not_used = sin_table[0];
	dummy_variable_not_used = current_Waveform[0];
}

void tim2_isr(void) {
    // Check if the update interrupt flag is set

    if (timer_get_flag(TIM2, TIM_SR_UIF)) {
        // Clear the interrupt flag
        timer_clear_flag(TIM2, TIM_SR_UIF);
		tick_counter ++;
		gpio_toggle(GPIOB, GPIO1);
		if(!OUT_BUFFER_EMPTY)
		{
			// write_voltage_to_dac(outputBuffer[bufferTail]);
			// curVoltSignal = outputBuffer[bufferTail++] & ~(0b1111<<12);
		}

		audioSampleEventInterruptFlag = true;
    }
}

void tmp_init_dac(void);
void tmp_init_dac()
{
	rcc_periph_clock_enable(RCC_SPI2);
    rcc_periph_clock_enable(RCC_DMA2); //DMA
	

	rcc_osc_on(RCC_PLLSAI);

	rcc_pllsai_config(50, 0, 5, 5);


    gpio_mode_setup(GPIOB, GPIO_MODE_AF, GPIO_PUPD_NONE, SAI1_FS_B_BLOCK_B | SAI1_SCK_B_BLOCK_B );
    gpio_mode_setup(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, SAI1_SD_B_BLOCK_A );
	
    gpio_set_af(GPIOB, GPIO_AF6, SAI1_FS_B_BLOCK_B | SAI1_SCK_B_BLOCK_B); 
    gpio_set_af(GPIOA, GPIO_AF6, SAI1_SD_B_BLOCK_A); 

	//dma setup

    dma_stream_reset(DMA2, DMA_STREAM4);
    nvic_enable_irq(NVIC_DMA2_STREAM4_IRQ);
    nvic_set_priority(NVIC_DMA2_STREAM4_IRQ, 1); // Set interrupt priority 
    dma_enable_transfer_complete_interrupt(DMA2, DMA_STREAM4);
    dma_enable_half_transfer_interrupt(DMA2, DMA_STREAM4);
    dma_set_transfer_mode(DMA2, DMA_STREAM4, DMA_SxCR_DIR_MEM_TO_PERIPHERAL);
    dma_set_peripheral_address(DMA2, DMA_STREAM4, (uint32_t)&SAI_BDR);  // I2S data register address
    dma_set_memory_address(DMA2, DMA_STREAM4, (uint32_t)outputBuffer); 
    dma_set_number_of_data(DMA2, DMA_STREAM4, BUFF_SIZE);
	dma_enable_fifo_mode(DMA2, DMA_STREAM4);
    // Enable circular mode
    dma_enable_circular_mode(DMA2, DMA_STREAM4);
    dma_set_priority(DMA2, DMA_STREAM4, DMA_SxCR_PL_HIGH);
	dma_channel_select(DMA2, DMA_STREAM4, DMA_SxCR_CHSEL_1);
    dma_set_memory_size(DMA2, DMA_STREAM4, DMA_SxCR_MSIZE_32BIT);
    dma_set_peripheral_size(DMA2, DMA_STREAM4, DMA_SxCR_PSIZE_32BIT);
    dma_enable_memory_increment_mode(DMA2, DMA_STREAM4);

    //SAI configuration
	// RCC_APB2RSTR |= RCC_APB2RSTR_SAI1RST; //reset sai1
	RCC_APB2ENR |= RCC_APB2ENR_SAI1EN;	//enable sai1

	//RCC_PLLI2SCFGR = 0b0010 <<24; div factor. page 164 in rm
	//RCC_PLLSAICFGR = 0b0010 <<24; div factor. page 164 in rm



	SAI1_BCR1 = 0b111 << 5 //data size  111=32, 110=24
				| 1 << 9 //Signals generated by the SAI change on SCK falling edge, while signals received by the SAI are sampled on the SCK rising edge. This is correct
				| 1 << 17 //DMA enable
				| 1 << 19 //No divider used in the clock generator (in this case Master Clock Divider bit has no effect)
				;


	//frame config register
	SAI_BFRCR = 63 << 0// frame length
				|32	<< 8	//Frame synchronization active level length.
				|1 << 16 //Frame synchronization &// this is correct
				|1 << 17 //FSPOL: //this is correct
				|1 << 18 //FSOFF:	//probably correct
				;

	SAI_BSLOTR 	|= 0b10 << 16 //enable two slots
			 	| 0b10 << 8	//number of slots in an audio frame
				| 0b10 << 6	//slot size //correct
				| 0b0 << 0 //first bit offset
				;


	dma_enable_stream(DMA2, DMA_STREAM4);
	SAI1_BCR1 |= 1 << 16; //enable sai1	


}

int main(void) {
	
	init_clock();
	rcc_periph_clock_enable(RCC_GPIOC);
	rcc_periph_clock_enable(RCC_GPIOB);
	rcc_periph_clock_enable(RCC_GPIOA);

	// init_input(&inpState);
	// init_dac();
	tmp_init_dac();
	init_music(s_PER_TICK);
	//set mode to output
	gpio_mode_setup(GPIOB, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO2);
	gpio_mode_setup(GPIOB, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO1);
	gpio_clear(GPIOB, GPIO2);
	//Just wait
	for(int i = 0; i < 10000000 ; i++)
	{
		__asm volatile ("nop");
	}
	// init_timer2();
	// init_timer3();

	for(uint32_t i = 0; i < 256; i++)
	{
		outputBuffer[i] = 0b11011111111111110000000000000000 ;
		// outputBuffer[i] = i ;
	}

	
	while(1)
	{
		for(int i = 0; i < 5 ; i++)
		{
		__asm volatile ("nop");
		}
		// SAI_BDR = 0b11110000111100001111000011110000;
		continue;
		if(++sample_increment >= INPUT_EACH_N_SAMPLE)
		{
			sample_increment = 0;
			inputSampleEventInterruptFlag = true;
		}

		if(inputSampleEventInterruptFlag)
		{
			inputSampleEventInterruptFlag = false;
			input_update(&inpState);
		}

		if(!OUT_BUFFER_FULL)
		{
			uint32_t buff = music_play(0, &inpState);
			//music_write_to_buffer(4294967295);


		}
	}
}	
