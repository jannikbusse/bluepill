/*
 * Rui Santos 
 * Complete Project Details https://randomnerdtutorials.com
 */

// include TFT and SPI libraries
#include <TFT.h>  
#include <SPI.h>
// pin definition for Arduino UNO
#define cs   10
#define dc   9
#define rst  8
#define LEDPIN 5
#define SGNL_CLK  2
#define SGNL_DATA 3

#define MAX_BUFFER_SIZE 50


char buffer[MAX_BUFFER_SIZE]  = {' '};
volatile uint8_t byte_buffer = 0;
volatile uint8_t byte_buffer_idx = 0;
volatile bool timeout_event = false;

volatile int bufferPos = 0;
volatile bool sgnl_flag = false;

// create an instance of the library
TFT TFTscreen = TFT(cs, dc, rst);

void reset_byte_buffer()
{
  byte_buffer = 0;
  byte_buffer_idx = 0;
}

void com_timeout()
{
  reset_byte_buffer();
  clearBuffer();
  
}

ISR(TIMER1_OVF_vect)
{
  TCNT1 = 44440;
  int currentState = digitalRead(LEDPIN);
  digitalWrite(LEDPIN, !currentState);  
  timeout_event = true;
  TIMSK1 = 0;  // Enable Timer Overflow Interrupt


}

void initTimer()
{
  TCCR1A = 0;           // Init Timer1
  TCCR1B = 0;           // Init Timer1
  TCCR1B |= B00000100;  // Prescalar = 64
  TCNT1 = 0;        // Timer Preloading
  TIMSK1 |= B00000001;  // Enable Timer Overflow Interrupt
}

void IRQ_handler_sgnl_clck()
{
  sgnl_flag = true;
  //read bit into byte buffer
  byte_buffer |= digitalRead(SGNL_DATA) << byte_buffer_idx;
  byte_buffer_idx ++;
  
  //-----
  TCNT1 = 0;
   TIFR1 |= (1 << TOV1); 
  TIMSK1 |= B00000001;  // Enable Timer Overflow Interrupt



}

void setup() {

  //initialize the library
  TFTscreen.begin();
  pinMode(LEDPIN, OUTPUT);
  pinMode(SGNL_CLK, INPUT);  
  pinMode(SGNL_DATA, INPUT);  
  attachInterrupt(digitalPinToInterrupt(SGNL_CLK), IRQ_handler_sgnl_clck , CHANGE);
  initTimer();
  
  TFTscreen.background(0, 0, 0);
  TFTscreen.setTextSize(1);
  TFTscreen.stroke(255, 255, 255);
}

void clearBuffer()
{
  for(int i = 0; i < MAX_BUFFER_SIZE; i ++)
  {
    buffer[i] = ' ';
  }
  bufferPos = 0;
}

void checkForArgs()
{
  if(bufferPos >= 2)
   {
    if(buffer[0] == '#')
    {
      TFTscreen.setTextSize((int)(buffer[1] - '0'));
    }
   }
}

bool readStream()
{
    char curIn = byte_buffer;
    if (curIn == 0)
    {
      return true;
    }
    buffer[bufferPos] = curIn;
    bufferPos ++;   
    
    if(bufferPos == MAX_BUFFER_SIZE -1)
    {
      return true;
    }
    
  return false;
}

void loop() {
  if(sgnl_flag)
  {
    sgnl_flag = false;
    if(byte_buffer_idx >= 8)
     {
        if (readStream())
        {
          checkForArgs();
          TFTscreen.background(0, 0, 0);
          TFTscreen.text(buffer, 2, 30);
          clearBuffer();
          reset_byte_buffer();
        }
     }
  }
  if (timeout_event)
  {
    timeout_event = false;
    
    com_timeout();
  }

}